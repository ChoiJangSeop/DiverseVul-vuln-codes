int gnutls_error_to_alert(int err, int *level)
{
	int ret, _level = -1;

	switch (err) {		/* send appropriate alert */
	case GNUTLS_E_DECRYPTION_FAILED:
		/* GNUTLS_A_DECRYPTION_FAILED is not sent, because
		 * it is not defined in SSL3. Note that we must
		 * not distinguish Decryption failures from mac
		 * check failures, due to the possibility of some
		 * attacks.
		 */
		ret = GNUTLS_A_BAD_RECORD_MAC;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_DECOMPRESSION_FAILED:
		ret = GNUTLS_A_DECOMPRESSION_FAILURE;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER:
	case GNUTLS_E_ILLEGAL_SRP_USERNAME:
		ret = GNUTLS_A_ILLEGAL_PARAMETER;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_UNKNOWN_SRP_USERNAME:
		ret = GNUTLS_A_UNKNOWN_PSK_IDENTITY;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_ASN1_ELEMENT_NOT_FOUND:
	case GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND:
	case GNUTLS_E_ASN1_DER_ERROR:
	case GNUTLS_E_ASN1_VALUE_NOT_FOUND:
	case GNUTLS_E_ASN1_GENERIC_ERROR:
	case GNUTLS_E_ASN1_VALUE_NOT_VALID:
	case GNUTLS_E_ASN1_TAG_ERROR:
	case GNUTLS_E_ASN1_TAG_IMPLICIT:
	case GNUTLS_E_ASN1_TYPE_ANY_ERROR:
	case GNUTLS_E_ASN1_SYNTAX_ERROR:
	case GNUTLS_E_ASN1_DER_OVERFLOW:
	case GNUTLS_E_CERTIFICATE_ERROR:
		ret = GNUTLS_A_BAD_CERTIFICATE;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_UNKNOWN_CIPHER_SUITE:
	case GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM:
	case GNUTLS_E_INSUFFICIENT_CREDENTIALS:
	case GNUTLS_E_NO_CIPHER_SUITES:
	case GNUTLS_E_NO_COMPRESSION_ALGORITHMS:
	case GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM:
	case GNUTLS_E_SAFE_RENEGOTIATION_FAILED:
	case GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL:
		ret = GNUTLS_A_HANDSHAKE_FAILURE;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION:
		ret = GNUTLS_A_UNSUPPORTED_EXTENSION;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_USER_ERROR:
		ret = GNUTLS_A_USER_CANCELED;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_UNEXPECTED_PACKET:
	case GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET:
	case GNUTLS_E_PREMATURE_TERMINATION:
		ret = GNUTLS_A_UNEXPECTED_MESSAGE;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_REHANDSHAKE:
	case GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED:
		ret = GNUTLS_A_NO_RENEGOTIATION;
		_level = GNUTLS_AL_WARNING;
		break;
	case GNUTLS_E_UNSUPPORTED_VERSION_PACKET:
		ret = GNUTLS_A_PROTOCOL_VERSION;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE:
		ret = GNUTLS_A_UNSUPPORTED_CERTIFICATE;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_UNEXPECTED_PACKET_LENGTH:
		ret = GNUTLS_A_RECORD_OVERFLOW;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_INTERNAL_ERROR:
	case GNUTLS_E_NO_TEMPORARY_DH_PARAMS:
	case GNUTLS_E_NO_TEMPORARY_RSA_PARAMS:
		ret = GNUTLS_A_INTERNAL_ERROR;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_OPENPGP_GETKEY_FAILED:
		ret = GNUTLS_A_CERTIFICATE_UNOBTAINABLE;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_DH_PRIME_UNACCEPTABLE:
	case GNUTLS_E_NO_CERTIFICATE_FOUND:
		ret = GNUTLS_A_INSUFFICIENT_SECURITY;
		_level = GNUTLS_AL_FATAL;
		break;
	case GNUTLS_E_NO_APPLICATION_PROTOCOL:
		ret = GNUTLS_A_NO_APPLICATION_PROTOCOL;
		_level = GNUTLS_AL_FATAL;
		break;
	default:
		ret = GNUTLS_A_INTERNAL_ERROR;
		_level = GNUTLS_AL_FATAL;
		break;
	}

	if (level != NULL)
		*level = _level;

	return ret;
}